Promise构造函数的参数中的函数是同步代码,直接运行
process.nextTick在微任务中的优先级高于promise.then(),故先于promise.then()执行

常见的宏任务:(macrotasks)
    1.script(可以理解为外层同步代码)
    2.setTimeout和setInterval
    3.setImmediate(Node.js)
    4.I/O
    5.UI事件
    6.postMessage
常见的微任务:(microtasks)
    1.Promise后的then事件
    2.process.nextTick(Node,js)
    3.Object.observe
    4.MutaionObserver
    5.async/await

scrollWidth-->对象的实际内容的宽度,不包括边线宽度,当内容小于对象宽度时等于对象的宽度,会随着对象中内容超过可视区后而变大
clientWidth-->对象内容的可视区的宽度,不包括滚动条等边线,包括padding,会随着对象显示大小的变化而改变
offsetWidth-->对象整体的实际宽度,包括滚动条,边框,内填充,会随着对象显示大小的变化而改变
scrollHeight,clientHeight,offsetHeight同理

Promise.resolve(x)可以看做是new Promise(resolve => resolve(x))的简写,可以用于快速封装字面量对象或其他对象,将其封装成promise实例
箭头函数中的this是继承至他词法最近的一层普通函数的this指向

async/await 在底层转换成了 promise 和 then 回调函数。
也就是说，这是 promise 的语法糖。
每次我们使用 await,解释器都创建一个 promise 对象，
然后把剩下的 async 函数中的操作放到 then 回调函数中。
即await后紧跟的代码操作作为promise的参数，将await之后的代码操作放到then回调中。

jquery中的trigger方法只能触发由jquery添加监听的click事件，如果需要trigger a标签的click事件，将jquery对象转化为js对象即可，如$(".test")[0].click()

正数的原码=反码=补码
负数的原码:最后一位为1表示负数,其余位表示为该数的绝对值
负数的反码:符号位不变,其余位取反
负数的补码:符号位不变,在反码的基础上加1

进行运算时均使用补码进行运算

位操作符:
1.AND---&
    x & 0 = 0
    x & -1 = x
    例:判断奇偶:  n & 1 === 0 ? 偶 : 奇
2.OR---|
    x | 0 = x
    x | -1 = -1
3.XOR---^
    A,B不同时返回1，相同返回0
    x ^ x = 0
    x ^ 0 = x
    x ^ -1 = ~x
    x ^ a ^ a = x
    例:交换两个变量的值: a^=b;b^=a;a^=b;
4.NOT---~
    ~x = -(x+1)
    对x的补码进行按位取反，再转化成原码，最后转化为十进制数
按位移动操作符:
1.左移---<<
    将数字转化成二进制补码再进行左移
    x << y = x * Math.pow(2,y)
2.有符号右移--->>
    拷贝最左侧的符号位以填充，符号位没有被改变，也被称作"符号传播"
    将数字转化成二进制补码再进行左移
3.无符号右移--->>>
    向右移动指定位数,左侧用0填充,符号位变成了0.即使右移0个比特,结果也是非负的
    对于非负数,有符号右移和无符号右移总是返回相同的结果

数组的sort方法:
    比较函数接受两个参数,第一个参数要在第二个参数之前,则返回一个负数,相反,则返回一个正数.
    [1,2,3,4].sort(function(a,b){return a-b}) 按照升序排列
    其中,第一个参数对应的2,第二个参数对应的1

Object对象属性:
    数据属性:configurable,enumerable,writable,value
    访问器属性:configurable,enumerable,get,set
Object对象方法:
  对象属性方法:
    Object.defineProperty(对象,属性,{描述符}),定义属性
    Object.defineProperties(对象,{属性:{描述符}}),定义多个属性
    Object.getOwnPropertyDescriptor(对象,属性),return Object,获取属性的描述符
    实例对象.hasOwnProperty(属性),return Boolean,判断实例对象中是否有该属性
    in操作符返回true而hasOwnProperty()返回false,说明该属性存在于原型之中
    属性 in 实例对象,返回true则说明该属性在实例对象或者原型之中
    Object.keys(对象),return [string],只获取对象的实例属性
    Object.getOwnPropertyNames(对象),return [string],获取对象的所有实例属性,无论是否可枚举
  对象原型方法:
    对象1.isPrototypeOf(对象2),return Boolean,判断对象1是否是对象2的原型
    Object.getPrototypeOf(对象),获取对象的原型

组合使用构造函数模式和原型模式,即构造函数模式中写实例属性,原型模式中写共享的方法和属性

寄生构造函数模式与稳妥构造函数模式所创建的对象与构造函数之间没有关系,这两个模式都是在内部新创建一个对象后返回,故没有关系
即     people.__proto__!=People.prototype

原型链继承是通过创建实例,并将实例赋值给另一个的原型对象实现.实现的本质是用一个新类型的实例重写原型对象.
比如说是将A构造函数的实例赋给B构造函数的原型,B再创建实例c,这就是原型链继承

原型式继承:
    Object.create(): 创建的对象的原型对象是传入的对象
    例:var a = Object.create(A),即a.__proto__ = A
    var a = Object.create(A,{
        name:{
            value: 'fanyuhua',
            enumerable: true
        }
    })


